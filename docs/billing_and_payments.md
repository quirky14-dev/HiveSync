# **billing_and_payments.md**

### HiveSync Billing System — LemonSqueezy Integration

**Version:** 1.0
**Scope:** Backend billing engine, subscription management, checkout initiation, webhook handling, tier enforcement.
**Frontend marketing pages are NOT generated by Replit.**
**Backend and API requirements MUST be followed exactly.**

---

# 1. Overview

HiveSync uses **LemonSqueezy** for subscription payments and license management.
All upgrade, downgrade, renewal, and cancellation logic happens **server-side** inside the HiveSync backend (FastAPI).

Users may view subscription status via the HiveSync Web Account Portal (`web_portal.md`).  
All purchases, upgrades, and cancellations are still performed via backend-generated LemonSqueezy checkout sessions.

**The frontend NEVER directly contacts LemonSqueezy.**
**All billing links MUST be generated by the backend after verifying authentication.**

---

# 2. Subscription Tiers

HiveSync supports the following user tiers:

| Tier    | Code      | Description                                 |
| ------- | --------- | ------------------------------------------- |
| Free    | `free`    | Default tier for new accounts               |
| Pro     | `pro`     | Individual developers with increased limits |
| Premium | `premium` | Team, enterprise, heavy-usage workflows     |

Each user record includes:

| Column                   | Description                                            |
| ------------------------ | ------------------------------------------------------ |
| `tier`                   | The active HiveSync tier (`free`, `pro`, `premium`)    |
| `subscription_id`        | LemonSqueezy subscription ID (nullable for free tier)  |
| `subscription_status`    | active, paused, past_due, canceled                     |
| `subscription_renews_at` | datetime for next renewal (nullable for canceled/free) |
| `subscription_ends_at`   | optional end date after cancellation                   |
| `checkout_metadata`      | JSON for diagnostic use (optional)                     |

---

# 3. Authentication Required for Checkout

Before upgrading, users MUST be authenticated.
The backend must return:

```
401 Unauthorized
```

if the user tries to access billing endpoints without a valid session cookie or JWT.

The backend is responsible for enforcing login.

---

# 4. Backend Endpoints

## 4.1 POST `/billing/start-checkout`
**Offline Mode Restriction:** Billing checkout sessions cannot be created while the client is offline. Backend MUST return a structured `OFFLINE_FORBIDDEN` error when offline.


**Purpose:**
Create a LemonSqueezy checkout session for an authenticated user.

**Auth Required:** YES
**Input:**

```json
{
  "tier": "pro" | "premium",
  "billing_cycle": "monthly" | "yearly"
}
```

**Server-Side Logic:**

1. Check user authentication.
2. Validate tier and billing_cycle against supported options.
3. Create a LemonSqueezy checkout session via API.
4. Attach `user_id` in `custom_data` metadata:

   ```json
   { "user_id": <int> }
   ```
5. Store a local `checkout_metadata` row (optional).
6. Return the checkout URL:

```json
{ "checkout_url": "<LZ-hosted-checkout-url>" }
```

**Frontend Behavior:**

* Redirect browser to the returned URL.
* Never store or build checkout URLs manually.

---

## 4.2 POST `/billing/webhook`
**Billing Desync Detection:** If the webhook subscription state contradicts the database (e.g., DB shows premium but LemonSqueezy indicates cancellation or non-payment), backend MUST correct the DB immediately. LemonSqueezy is authoritative.


**Purpose:**
Receive official LemonSqueezy events and update user subscriptions.

**Authentication:**

* Verify HMAC signature (`X-Signature`) using LemonSqueezy signing secret.
* Reject all requests with invalid signature.

**Events to Handle:**

* `subscription_created`
* `subscription_updated`
* `subscription_cancelled`
* `subscription_expired`
* `subscription_paused`
* `subscription_resumed`
* `subscription_payment_failed`
* `subscription_payment_recovered`

**Webhook Payload Requirements:**

LemonSqueezy sends:

```json
{
  "event": "...",
  "meta": {},
  "data": {
    "attributes": {
      "status": "active",
      "renewal_date": "...",
      "ends_at": "...",
      "product_id": ...,
      "variant_id": ...,
      "subscription_id": "...",
      "customer_email": "...",
      "custom_data": {
        "user_id": <int>
      }
    }
  }
}
```

**Backend Workflow:**

1. Validate signature.
2. Extract `user_id` from `custom_data`.
3. Fetch the corresponding user.
4. Update DB accordingly:

| Event                    | Action                                                                                         |
| ------------------------ | ---------------------------------------------------------------------------------------------- |
| `subscription_created`   | Set tier based on product/variant; mark status active; store subscription_id; set renewal date |
| `subscription_updated`   | Update renewal date, tier (if changed), status                                                 |
| `subscription_cancelled` | Mark status canceled; set ends_at                                                              |
| `subscription_expired`   | Set tier to free; subscription_status = expired                                                |
| `subscription_paused`    | subscription_status = paused                                                                   |
| `subscription_resumed`   | subscription_status = active                                                                   |
| payment_failed           | log failure; optional downgrade to free after grace period                                     |

**Return Response:**

```
200 OK
```

All webhook processing must be idempotent using the supplied `subscription_id`.

---

# 5. Mapping Product/Variant IDs to Tiers

The backend must have a mapping table:

```python
VARIANT_TO_TIER = {
    "PRO_VARIANT_ID_MONTHLY": "pro",
    "PRO_VARIANT_ID_YEARLY": "pro",
    "PREMIUM_VARIANT_ID_MONTHLY": "premium",
    "PREMIUM_VARIANT_ID_YEARLY": "premium"
}
```

These IDs are configured in environment variables:

```
LZ_PRO_MONTHLY_VARIANT_ID=
LZ_PRO_YEARLY_VARIANT_ID=
LZ_PREMIUM_MONTHLY_VARIANT_ID=
LZ_PREMIUM_YEARLY_VARIANT_ID=
```

---

# 6. Tier Enforcement in the Backend

Backend endpoints must read `request.user.tier` and adjust limits:

### Example behaviors:

| Tier    | Preview Limits | AI Doc Limits | Queue Priority      |
| ------- | -------------- | ------------- | ------------------- |
| free    | low            | low           | low                 |
| pro     | higher         | moderate      | medium              |
| premium | highest        | highest       | high (GPU priority) |

All preview, AI, and refactor endpoints MUST enforce these limits based on `user.tier`.

Tier logic must not use emails or heuristics — it must use DB tier column.

## 6.1 Architecture Map & CSS Influence Analysis Tier Gates

The extended Architecture Map (including HTML/CSS layers and CSS Influence Analysis) must respect the same tier model:

- **Free**
  - Limited Architecture Map generations (as defined elsewhere in this doc).
  - Access to HTML/CSS layers with Basic CIA only.
  - No deep CSS lineage view and no selector muting.

- **Pro**
  - All Free-tier capabilities.
  - Extended map history and diff support for HTML/CSS where allowed.
  - Full Basic CIA for CSS selectors and HTML elements.

- **Premium**
  - Full Deep CIA (override lineage, specificity graphs, inheritance tracing).
  - Selector muting simulation.
  - Full multi-layer comparison (Code / HTML / CSS / External / API) with no additional tier restrictions beyond global map limits.

Backend enforcement:

- Backend must validate `request.user.tier` before triggering deep CIA or selector muting.
- If a user on an insufficient tier requests these features, endpoints must return a tier-specific error (e.g. `TIER_UPGRADE_REQUIRED`) instead of a generic failure.

---

# 7. Preventing Fraud & Misuse

The backend MUST:

* Reject checkout creation if user unauthenticated.
* Never use email matching for billing identity.
* Only trust webhook `custom_data.user_id`.
* Reject ALL webhook events missing user_id in metadata.
* Prevent multiple active subscriptions per user unless explicitly enabled.
* Require the user to be logged in before generating checkout URLs.

---

# 8. Subscription Cancellation Flow

Users may cancel via:

* Their HiveSync account page
* LemonSqueezy customer portal

Backend logic:

1. User requests cancellation → call LemonSqueezy API to cancel subscription.
2. Webhook event finalizes the cancellation.
3. Downgrade user tier to `free` only when LS indicates `subscription_expired` or past grace period.

---

# 9. Refund Handling

Refund activity is controlled externally through LemonSqueezy.

Webhook event `order_refunded` should:

* Record refund for audit
* (Optional) Immediately downgrade tier
* (Optional) Mark subscription as refunded/canceled

---

# 10. Session-Token Login (Mobile → Web)

Billing relies on correct login flow.

Backend endpoints:

### POST `/auth/session-token`

* Creates short-lived (60–120 sec) one-time login token
* Attaches user_id
* Not tied to device
* Not reusable

### GET `/login/session/<token>`

Frontend calls:

```
POST /auth/session-exchange
```

Backend:

* Validates token
* Marks token as used
* Creates user session cookie
* Returns success

Then billing links become active because user is authenticated.

---

## 11. Billing Provider Authority & Webhook-Driven Tier State (LemonSqueezy)

### Billing Authority

LemonSqueezy is the billing provider of record.
Subscription state changes MUST be accepted exclusively via provider webhooks.

Clients MUST NOT:
- set or override tier state,
- submit “upgrade” data to the API as proof of payment,
- bypass billing by manipulating local storage or request payloads.

> Cross-reference: Phase L defines tier semantics (Free/Pro/Premium) and how upgrades/downgrades affect limits; backend_spec defines runtime enforcement and webhook processing.

### Webhook-Driven Flow (High-Level)

1. LemonSqueezy sends a signed webhook event to the backend.
2. Backend verifies signature + idempotency.
3. Backend resolves the billing subject (user or team/org).
4. Backend maps provider plan/variant to internal tier (Free/Pro/Premium).
5. Backend persists billing state and invalidates entitlements caches.
6. Clients learn about tier changes via normal API responses and refresh entitlements when required.

### Upgrade Timing

Upgrades take effect as soon as LemonSqueezy confirms the new tier.
Active sessions must refresh entitlements.
In-flight jobs are not retroactively killed mid-run; new limits apply on subsequent requests.

### Downgrade Timing

Downgrades take effect when the downgrade becomes effective (per provider state).
New, lower limits apply to future tier-sensitive actions.
Existing stored data is not immediately deleted; cleanup policy is governed elsewhere (backend_spec + admin tooling).

### Plan → Tier Mapping

Backend maintains a server-side mapping table from LemonSqueezy product/variant identifiers to internal tier.
This mapping MUST NOT be configurable from the client.

### Refunds, Chargebacks, and Payment Failures

If provider state indicates non-payment / cancellation / expiry:
- backend transitions the billing subject to the appropriate reduced tier (typically Free),
- enforcement changes apply immediately to subsequent tier-sensitive actions.

### Auditing & Support

Backend stores enough billing receipt metadata to:
- explain current tier,
- trace last known provider event,
- support customer service disputes,
without exposing sensitive provider payloads to end users.


---

# 12. Final Notes

* All billing logic is backend-only.
* The marketing website hosted on Cloudflare Pages does NOT handle billing.
* Checkout URLs must NEVER appear in code, HTML, or public links.
* The backend constructs the checkout session each time based on user identity.
* The backend must log webhook calls for audit.
* Replit MUST generate code following this specification exactly.

---

# End of Document

**billing_and_payments.md — HiveSync Billing System**
Version 1.0

